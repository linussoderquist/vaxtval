<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hitta lämpliga inhemska växtarter</title>
  <link rel="icon" href="icon.png" type="image/png" sizes="32x32">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0b0f14;--panel:#0d1420;--text:#ecf1f6;--muted:#a5b6c9;--line:#1a2533}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:'Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Noto Sans',Arial,sans-serif}
    header{padding:12px 16px;border-bottom:1px solid var(--line);background:var(--panel)}
    h1{margin:0 0 8px;font-size:28px;font-weight:700;letter-spacing:.2px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .controls label, .controls span{font-size:14px}
    input[type="number"]{width:120px;background:#0a1320;border:1px solid #263447;color:var(--text);border-radius:8px;padding:8px 10px}
    button{background:#0f2134;border:1px solid #2b4460;border-radius:12px;color:#eaf2fa;padding:9px 14px;cursor:pointer}
    button:hover{filter:brightness(1.06)}
    #statusMsg{font-size:13px;color:var(--muted)}
    #map{height:62vh}
    #resultWrapper{height:32vh;overflow-y:auto;border-top:1px solid var(--line)}
    table{width:100%;border-collapse:separate;border-spacing:0 6px;margin:12px 0}
    thead th{font-size:13px;color:var(--muted);text-align:left;cursor:pointer;padding:6px 8px;background:#0e1724;position:sticky;top:0;z-index:1}
    tbody tr{background:#0f1723;border:1px solid #1e2b3b}
    tbody td{padding:8px 10px}
    tr:hover{outline:1px solid #27405f}
    tr.selected{outline:2px solid gold;background-color:#3b2b00}
    .tag{font-size:11px;border:1px solid #2a4462;border-radius:999px;padding:2px 6px;color:#cfe1ff;background:#0e1b2f}
    #csvPicker{display:none}

    /* Donut i mitten */
    #progressContainer{
      display:none; position:fixed; z-index:9999; inset:0;
      background:rgba(0,0,0,.35);
    }
    #progressInner{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width:160px;height:160px;padding:10px;border-radius:18px;
      background:rgba(13,20,32,.95); box-shadow:0 12px 36px rgba(0,0,0,.45);
    }
    #progressDonut{display:block;margin:0 auto}
    #progressInner img{position:absolute;top:50%;left:50%;width:56px;height:56px;transform:translate(-50%,-50%);pointer-events:none}
    .num { font-variant-numeric: tabular-nums; }
    .tight { white-space:nowrap; }
  </style>
</head>
<body>
  <header>
    <h1>Hitta lämpliga inhemska växtarter</h1>
    <div class="controls">
      <label id="csvPicker">vaxtdata.csv
        <input type="file" id="csvInput" accept=".csv">
      </label>

      <!-- Insamlingsradie + Hämta -->
      Radie (m):
      <input type="number" id="radiusInput" value="500" min="10" step="10">
      <button id="fetchBtn">Hämta observationer</button>

      <!-- Konnektivitet -->
      <span class="tight">Spridningsradie (m):</span>
      <input type="number" id="connRadius" value="1000" min="50" step="50">
      <button id="analyzeBtn">Analysera konnektivitet</button>

      <span id="statusMsg"></span>
    </div>
  </header>

  <!-- Donut-progress i centrum -->
  <div id="progressContainer">
    <div id="progressInner">
      <canvas id="progressDonut" width="160" height="160"></canvas>
      <img src="icon.png" alt="ikon">
    </div>
  </div>

  <div id="map"></div>

  <div id="resultWrapper">
    <table id="resultTable">
      <thead>
        <tr>
          <th>Svenskt namn</th>
          <th>Vetenskapligt namn</th>
          <th>Biodiversitet</th>
          <th>Nektar</th>
          <th>Antal</th>
          <th>Växtsätt</th>
          <th>Medelhöjd (m)</th>
          <th>Ljus</th>
          <th>Fukt</th>
          <th>Salt</th>
          <!-- Nya konnektivitetskolumner (per art) -->
          <th class="tight" title="Komponenter före">Comp F</th>
          <th class="tight" title="Komponenter efter">Comp E</th>
          <th class="tight" title="Minskning av komponenter">ΔComp</th>
          <th class="tight" title="Giant Component Fraction före">GCF F</th>
          <th class="tight" title="Giant Component Fraction efter">GCF E</th>
          <th class="tight" title="Fragmentering 1−Σs²/n² före">Frag F</th>
          <th class="tight" title="Fragmentering 1−Σs²/n² efter">Frag E</th>
          <th class="tight" title="Direkta länkar från ny punkt">Links</th>
          <th class="tight" title="Betweenness centrality (ny punkt)">BC(new)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
  /* ================= CONFIG ================= */
  const SOS_API_KEY = "946a74eee3384494b1905c06ad4420b0";

  /* ================ Hjälpare ================ */
  const $ = s => document.querySelector(s);
  const statusEl = $('#statusMsg');
  const setStatus = t => statusEl.textContent = t || '';
  const asNumber = x => { const n=parseFloat(String(x??'').replace(',','.')); return Number.isFinite(n)? n : null; };
  const toMetersFromCm = v => { const n=asNumber(v); return n==null? null : n/100; };
  const escapeHTML = s => String(s).replace(/[&<>\"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const fmt2 = x => Number.isFinite(x) ? (Math.round(x*100)/100).toString() : '–';
  const fmt3 = x => Number.isFinite(x) ? (Math.round(x*1000)/1000).toString() : '–';

  function normalizeSciName(s){
    if(!s) return '';
    return String(s)
      .replace(/\s+subsp\..*/i,'').replace(/\s+var\..*/i,'')
      .replace(/\s+\(.+?\)/g,'').replace(/\s+[A-ZÅÄÖ][a-z]+\.?$/,'')
      .trim().split(/\s+/).slice(0,2).join(' ').toLowerCase();
  }
  function getAcceptedDyntaxaId(props){
    const raw = props["Godkänd namnanvändande id"] || props.acceptedNameUsageID || props.acceptedNameUsageId || '';
    if(!raw) return null;
    const m = String(raw).match(/Taxon:(\d+)/);
    return m ? m[1] : null;
  }

  // Donut-progress (center)
  function showProgress(){ $('#progressContainer').style.display='block'; updateProgress(0); }
  function hideProgress(){ $('#progressContainer').style.display='none'; }
  function updateProgress(frac){
    const canvas=$('#progressDonut'), ctx=canvas.getContext('2d'), s=canvas.width;
    ctx.clearRect(0,0,s,s);
    // bakgrundring
    ctx.beginPath(); ctx.arc(s/2,s/2,s/2-8,0,2*Math.PI); ctx.strokeStyle='#223344'; ctx.lineWidth=14; ctx.stroke();
    // progressring
    ctx.beginPath(); ctx.arc(s/2,s/2,s/2-8,-Math.PI/2,-Math.PI/2+2*Math.PI*frac); ctx.strokeStyle='#77aaff'; ctx.lineWidth=14; ctx.stroke();
  }

  function parseCSV(text, delimiter=';'){
    const rows=[]; let i=0, field='', row=[], inQ=false;
    const pushF=()=>{row.push(field); field='';}; const pushR=()=>{rows.push(row); row=[];};
    while(i<text.length){
      const c=text[i];
      if(inQ){ if(c==='"'){ if(text[i+1]==='"'){ field+='"'; i++; } else inQ=false; } else field+=c; }
      else { if(c==='"') inQ=true; else if(c===delimiter) pushF(); else if(c==='\n'){ pushF(); pushR(); } else if(c!=='\r') field+=c; }
      i++;
    }
    if(field.length>0 || row.length>0){ pushF(); pushR(); }
    return rows.filter(r=> r.some(v=> String(v).trim().length>0));
  }

  /* ============== Data från CSV ============== */
  const speciesCsvById = new Map();
  const speciesByNorm  = new Map();
  let csvLoaded = false;

  async function loadCsvAuto(){
    if(location.protocol.startsWith('http')){
      try{
        const res = await fetch('vaxtdata.csv', {cache:'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const txt = await res.text();
        await indexCsvText(txt);
        return;
      }catch{}
    }
    $('#csvPicker').style.display='inline';
  }

  async function indexCsvText(txt){
    const rows = parseCSV(txt,';');
    const head = rows[0].map(h=>String(h).trim().toLowerCase());
    const idx = {
      dyntaxa: head.indexOf('dyntaxa id number'),
      sv: head.indexOf('svenskt namn'),
      sci: head.indexOf('scientific name'),
      bio: head.findIndex(h=>h.includes('biodivers')),
      nec: head.findIndex(h=>h.includes('nektar')),
      growth: head.findIndex(h=>h.includes('växtsätt')||h.includes('vaxtsätt')||h.includes('vaxtsatt')||h.includes('växtsatt')),
      height: head.findIndex(h=>h.includes('medelhöjd')),
      light: head.findIndex(h=>h==='light'||h.includes('ljus')),
      moist: head.findIndex(h=>h==='moisture'||h.includes('fukt')),
      salt: head.findIndex(h=>h==='salinity'||h.includes('salttålighet')||h.includes('salt'))
    };
    if(idx.sci===-1 || idx.sv===-1) throw new Error('CSV saknar Scientific name / Svenskt namn');

    speciesCsvById.clear(); speciesByNorm.clear();
    for(let r=1;r<rows.length;r++){
      const row=rows[r];
      const dx  = String(row[idx.dyntaxa]||'').trim();
      const sci = String(row[idx.sci]||'').trim();
      if(!sci) continue;
      const rec = {
        dyntaxa: dx,
        svName: row[idx.sv] || '',
        sciName: sci,
        biodiv: idx.bio>=0? asNumber(row[idx.bio]) : null,
        nectar: idx.nec>=0? asNumber(row[idx.nec]) : null,
        growth: idx.growth>=0? row[idx.growth] : '',
        height: idx.height>=0? toMetersFromCm(row[idx.height]) : null,
        light:  idx.light>=0? row[idx.light]  : '',
        moist:  idx.moist>=0? row[idx.moist]  : '',
        salt:   idx.salt>=0?  row[idx.salt]   : ''
      };
      if(dx) speciesCsvById.set(dx, rec);
      speciesByNorm.set(normalizeSciName(sci), rec);
    }
    csvLoaded = true;
  }

  $('#csvInput').addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{ const txt=await f.text(); await indexCsvText(txt); setStatus('CSV klar.'); }catch(err){ setStatus('CSV-fel: '+err.message); }
  });

  /* ================== Karta ================== */
  const map = L.map('map').setView([62,15],5);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
  let selectedPoint=null, clickMarker=null, bufferCircle=null;
  const layerAll = L.layerGroup().addTo(map);
  const layerSelected = L.layerGroup().addTo(map);
  const layerLinks = L.layerGroup().addTo(map);   // nätverks-länkar

  map.on('click', e=>{
    selectedPoint = e.latlng;
    drawSelection();
    setStatus('');
  });

  function drawSelection(){
    const r = +$('#radiusInput').value||0;
    if(clickMarker) clickMarker.remove();
    if(bufferCircle) bufferCircle.remove();
    if(!selectedPoint || !r) return;
    clickMarker = L.marker(selectedPoint).addTo(map);
    bufferCircle = L.circle(selectedPoint, {radius:r, color:'#77f', fillOpacity:0.05}).addTo(map);
  }

  /* ================ SOS Export ================ */
  function circlePolygon(lon, lat, radiusMeters, steps=96){
    const R=6371000, coords=[];
    for(let i=0;i<=steps;i++){
      const a=2*Math.PI*(i/steps);
      const dx=(radiusMeters/R)*Math.cos(a), dy=(radiusMeters/R)*Math.sin(a);
      const lat2=lat + (dy*180/Math.PI);
      const lon2=lon + (dx*180/Math.PI)/Math.cos(lat*Math.PI/180);
      coords.push([lon2, lat2]);
    }
    return {type:'Polygon',coordinates:[coords]};
  }

  async function fetchFromSOS(lat, lng, radiusMeters){
    if(!SOS_API_KEY || SOS_API_KEY.includes('DIN_API_NYCKEL')) throw new Error('Sätt SOS_API_KEY i koden.');
    if(!Number.isFinite(lat)||!Number.isFinite(lng)||!Number.isFinite(radiusMeters)||radiusMeters<=0) throw new Error('Ogiltig punkt eller radie.');
    const url='https://api.artdatabanken.se/species-observation-system/v1/Exports/Download/GeoJson'
      + '?validateSearchFilter=false&propertyLabelType=Swedish&cultureCode=sv-SE'
      + '&flat=true&excludeNullValues=false&gzip=false&sensitiveObservations=false';
    const body={
      determinationFilter:'NoFilter',
      occurrenceStatus:'Present',
      verificationStatus:'BothVerifiedAndNotVerified',
      geographics:{geometries:[circlePolygon(lng,lat,radiusMeters)]},
      output:{fieldSet:'All'},
      taxon:{attributes:{}}
    };
    const res=await fetch(url,{method:'POST',headers:{
      'Content-Type':'application/json','Accept':'application/json','X-Api-Version':'1.5',
      'Ocp-Apim-Subscription-Key':SOS_API_KEY
    },body:JSON.stringify(body)});
    if(!res.ok){ let txt=''; try{txt=await res.text();}catch{}; throw new Error(`SOS ${res.status} ${txt.slice(0,200)}`); }
    const gj=await res.json();
    return Array.isArray(gj?.features)? gj.features : [];
  }

  /* ============ Graph utils & metrics ============ */
  function haversineMeters(lat1, lon1, lat2, lon2){
    const R=6371000;
    const dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }
  class UF{
    constructor(n){ this.p=Array.from({length:n},(_,i)=>i); this.r=new Array(n).fill(0); this.sz=new Array(n).fill(1);}
    find(x){ return this.p[x]===x? x : (this.p[x]=this.find(this.p[x])); }
    union(a,b){ a=this.find(a); b=this.find(b); if(a===b) return;
      if(this.r[a]<this.r[b]) [a,b]=[b,a]; this.p[b]=a; this.sz[a]+=this.sz[b]; if(this.r[a]===this.r[b]) this.r[a]++; }
    compSizes(){ const m=new Map(); for(let i=0;i<this.p.length;i++){ const r=this.find(i); m.set(r,(m.get(r)||0)+1);} return [...m.values()]; }
  }
  function buildGraph(points, threshM){
    const n = points.length;
    const adj = Array.from({length:n}, ()=>[]);
    const edges = [];
    const deg = new Array(n).fill(0);
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const d=haversineMeters(points[i][0],points[i][1],points[j][0],points[j][1]);
        if(d<=threshM){
          adj[i].push(j); adj[j].push(i);
          edges.push([i,j]);
          deg[i]++; deg[j]++;
        }
      }
    }
    return {adj, edges, deg, n};
  }
  function degreeCentrality(deg, n){ const den=Math.max(1,n-1); return deg.map(d=>d/den); }
  function brandesBetweenness(adj){
    const n = adj.length;
    const CB = new Array(n).fill(0);
    const S = [];
    const P = Array.from({length:n},()=>[]);
    const sigma = new Array(n);
    const d = new Array(n);
    const Q = [];
    for(let s=0; s<n; s++){
      for(let i=0;i<n;i++){ P[i]=[]; sigma[i]=0; d[i]=-1; }
      sigma[s]=1; d[s]=0; S.length=0; Q.length=0; Q.push(s);
      while(Q.length){
        const v=Q.shift(); S.push(v);
        for(const w of adj[v]){
          if(d[w]<0){d[w]=d[v]+1; Q.push(w);}
          if(d[w]===d[v]+1){ sigma[w]+=sigma[v]; P[w].push(v); }
        }
      }
      const delta=new Array(n).fill(0);
      while(S.length){
        const w=S.pop();
        for(const v of P[w]) delta[v]+= (sigma[v]/sigma[w])*(1+delta[w]);
        if(w!==s) CB[w]+=delta[w];
      }
    }
    const normDen = (n>2) ? ((n-1)*(n-2)/2) : 1;
    return CB.map(v=> v/normDen);
  }
  function componentsFor(points, threshM){
    const n=points.length, uf=new UF(n);
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const d=haversineMeters(points[i][0],points[i][1],points[j][0],points[j][1]);
        if(d<=threshM) uf.union(i,j);
      }
    }
    const sizes=uf.compSizes();
    const compCount=sizes.length;
    const maxComp = sizes.length? Math.max(...sizes) : 0;
    const nTot = n;
    const gcf = nTot>0 ? (maxComp / nTot) : 0;
    const sumSq = sizes.reduce((s,v)=>s+v*v,0);
    const frag = nTot>0 ? (1 - (sumSq / (nTot*nTot))) : 0;
    return {compCount, maxComp, gcf, frag, n: nTot};
  }
  function drawEdgesWithDegreeStyling(points, edges, degC, color){
    for(const [i,j] of edges){
      const avg = (degC[i] + degC[j]) / 2;
      const weight = 0.5 + 4.0 * avg;
      const opacity = 0.25 + 0.65 * avg;
      L.polyline([[points[i][0],points[i][1]],[points[j][0],points[j][1]]],
        {color, weight, opacity}).addTo(layerLinks);
    }
  }

  /* ========== App-state ========== */
  let _featuresBySpecies = []; // [{csv, feats, count, score}, ...] efter Hämta
  let _lastRows = [];
  let _speciesMetrics = new Map(); // key -> metrics

  /* ============== Hämta obs ============== */
  $('#fetchBtn').addEventListener('click', async ()=>{
    if(!selectedPoint){ setStatus('Klicka i kartan för att välja plats.'); return; }
    const r = +$('#radiusInput').value || 0; if(r<=0){ setStatus('Ange radie > 0.'); return; }
    try{
      if(!csvLoaded){ setStatus('CSV laddas…'); }
      showProgress(); updateProgress(0.2);
      const feats = await fetchFromSOS(selectedPoint.lat, selectedPoint.lng, r);
      updateProgress(0.55);

      const per = new Map(); // gruppKey -> {count,csv,feats}
      for (const f of feats){
        const p = f.properties || {};
        const dxAccepted = getAcceptedDyntaxaId(p);
        const dxRaw = String(p["Dyntaxa taxon id"] ?? p["Taxon ID"] ?? p.dyntaxaTaxonId ?? p.taxonId ?? '').trim();
        const sciRaw = String(p["Vetenskapligt namn"] ?? p.scientificName ?? '').trim();
        const norm = normalizeSciName(sciRaw);

        let csv = null;
        if (dxAccepted && speciesCsvById.has(dxAccepted))      csv = speciesCsvById.get(dxAccepted);
        else if (dxRaw && speciesCsvById.has(dxRaw))           csv = speciesCsvById.get(dxRaw);
        else if (speciesByNorm.has(norm))                      csv = speciesByNorm.get(norm);
        else                                                   continue;

        const groupKey = csv.dyntaxa && String(csv.dyntaxa).trim()
                        ? String(csv.dyntaxa).trim()
                        : (normalizeSciName(csv.sciName) || norm || sciRaw.toLowerCase());

        if(!per.has(groupKey)) per.set(groupKey, { count:0, csv, feats:[] });
        const rec = per.get(groupKey); rec.count++; rec.feats.push(f);
      }

      const rows=[...per.values()].map(r=>({...r,score:(r.csv.biodiv??0)*2+(r.csv.nectar??0)}))
                  .sort((a,b)=>{const s=(b.score??0)-(a.score??0); if(s) return s; return (b.count??0)-(a.count??0);});

      _featuresBySpecies = rows;
      _speciesMetrics.clear(); // reset metrics (kräver ny Analys)
      renderTable(rows);
      plotAllPoints(rows);
      setStatus(rows.length? '' : 'Inga arter matchade CSV inom vald radie.');
      updateProgress(1.0); setTimeout(hideProgress,350);
    }catch(err){ console.error(err); setStatus('Fel: '+err.message); hideProgress(); }
  });

  /* ======= Analys per art -> fyll tabellkolumner ======= */
  $('#analyzeBtn').addEventListener('click', ()=>{
    if(!_featuresBySpecies.length){ setStatus('Hämta observationer först.'); return; }
    if(!selectedPoint){ setStatus('Klicka i kartan för att välja plats.'); return; }
    const thresh = +$('#connRadius').value || 1000;

    // Beräkna per art och uppdatera celler
    for(const rec of _featuresBySpecies){
      const key = rec.csv.dyntaxa || normalizeSciName(rec.csv.sciName);
      const feats = rec.feats;
      const pts = [];
      for(const f of feats){
        const g=f.geometry; if(!g||g.type!=='Point') continue;
        const [lon,lat]=g.coordinates; pts.push([lat,lon]);
      }
      if(!pts.length) continue;

      // Före/efter
      const before = componentsFor(pts, thresh);
      const withNew = pts.concat([[selectedPoint.lat, selectedPoint.lng]]);
      const after  = componentsFor(withNew, thresh);

      // Bygg graf för betweenness + links (efter)
      const Gafter = buildGraph(withNew, thresh);
      const BC = brandesBetweenness(Gafter.adj);
      const newIdx = withNew.length-1;
      const bcNew = (Gafter.n>1) ? BC[newIdx] : 0;
      const links = (Gafter.adj[newIdx]||[]).length;

      const metrics = {
        compF: before.compCount, compE: after.compCount, dComp: before.compCount - after.compCount,
        gcfF: before.gcf, gcfE: after.gcf,
        fragF: before.frag, fragE: after.frag,
        links, bcNew
      };
      _speciesMetrics.set(key, metrics);
    }
    // uppdatera tabellceller
    updateMetricsCells();
    setStatus('Konnektivitetsmått uppdaterade.');
  });

  function updateMetricsCells(){
    const tbody = $('#resultTable tbody');
    for(const tr of tbody.querySelectorAll('tr')){
      const key = tr.dataset.key;
      const m = _speciesMetrics.get(key);
      const cells = tr.querySelectorAll('td');
      const baseCols = 10; // fasta kolumner före mått
      if(m){
        cells[baseCols+0].textContent = m.compF;
        cells[baseCols+1].textContent = m.compE;
        cells[baseCols+2].textContent = m.dComp;
        cells[baseCols+3].textContent = fmt2(m.gcfF);
        cells[baseCols+4].textContent = fmt2(m.gcfE);
        cells[baseCols+5].textContent = fmt2(m.fragF);
        cells[baseCols+6].textContent = fmt2(m.fragE);
        cells[baseCols+7].textContent = m.links;
        cells[baseCols+8].textContent = fmt3(m.bcNew);
      }else{
        for(let i=0;i<9;i++) cells[baseCols+i].textContent = '–';
      }
    }
  }

  /* ========= Tabell & karta (UI) ========= */
  function renderTable(items){
    const tb=$('#resultTable tbody'); tb.innerHTML='';
    _lastRows = items;
    for(const rec of items){
      const c=rec.csv;
      const key = c.dyntaxa || normalizeSciName(c.sciName);
      const tr=document.createElement('tr'); tr.tabIndex=0; tr.dataset.sci=c.sciName; tr.dataset.key=key;
      tr.innerHTML =
        `<td>${escapeHTML(c.svName||'')}</td>`+
        `<td><i>${escapeHTML(c.sciName||'')}</i></td>`+
        `<td class="num">${c.biodiv??'–'}</td>`+
        `<td class="num">${c.nectar??'–'}</td>`+
        `<td class="num">${rec.count}</td>`+
        `<td><span class="tag">${escapeHTML(c.growth||'')}</span></td>`+
        `<td class="num">${c.height==null? '–' : c.height.toFixed(2)}</td>`+
        `<td>${escapeHTML(c.light||'')}</td>`+
        `<td>${escapeHTML(c.moist||'')}</td>`+
        `<td>${escapeHTML(c.salt||'')}</td>`+
        // plats för 9 metric-celler
        `<td class="num">–</td><td class="num">–</td><td class="num">–</td>`+
        `<td class="num">–</td><td class="num">–</td>`+
        `<td class="num">–</td><td class="num">–</td>`+
        `<td class="num">–</td><td class="num">–</td>`;
      tr.addEventListener('click',()=> selectSpecies(key));
      tr.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); selectSpecies(key);} });
      tb.appendChild(tr);
    }
    makeSortable();
    updateMetricsCells(); // ifall metrics redan finns
  }

  function plotAllPoints(items){
    layerAll.clearLayers(); layerSelected.clearLayers(); layerLinks.clearLayers();
    const markers=[];
    for(const rec of items){
      for(const f of rec.feats){
        const g=f.geometry; if(!g||g.type!=='Point') continue;
        const [lon,lat]=g.coordinates;
        const m=L.circleMarker([lat,lon],{radius:3,color:'#6ea8ff',fillOpacity:.6});
        m.addTo(layerAll); markers.push(m);
      }
    }
    if(markers.length) map.fitBounds(L.featureGroup(markers).getBounds().pad(0.2));
  }

  function selectSpecies(key){
    document.querySelectorAll('#resultTable tbody tr').forEach(tr=> tr.classList.toggle('selected', tr.dataset.key===key));
    const rec=(_lastRows||[]).find(r=>{
      const k = r.csv.dyntaxa || normalizeSciName(r.csv.sciName);
      return k===key;
    });
    if(!rec) return;
    // markera punkter
    layerSelected.clearLayers(); layerLinks.clearLayers();
    const pts=[];
    for(const f of rec.feats){
      const g=f.geometry; if(!g||g.type!=='Point') continue;
      const [lon,lat]=g.coordinates;
      const m=L.circleMarker([lat,lon],{radius:6,color:'#FFD700',weight:2,fillColor:'#FFD700',fillOpacity:.6});
      m.addTo(layerSelected); pts.push([lat,lon]);
    }
    if(pts.length) map.fitBounds(L.featureGroup(layerSelected.getLayers()).getBounds().pad(0.2));

    // rita nätverk baserat på nuvarande spridningsradie
    const thresh = +$('#connRadius').value || 1000;
    // före (blå kanter)
    const Gbefore = buildGraph(pts, thresh);
    const degC_before = degreeCentrality(Gbefore.deg, Gbefore.n);
    drawEdgesWithDegreeStyling(pts, Gbefore.edges, degC_before, '#3aa0ff');

    // efter (ny punkt guld)
    if(selectedPoint){
      const withNew = pts.concat([[selectedPoint.lat, selectedPoint.lng]]);
      const Gafter = buildGraph(withNew, thresh);
      const degC_after = degreeCentrality(Gafter.deg, Gafter.n);
      const newIdx = withNew.length-1;
      for(const nb of Gafter.adj[newIdx]){
        const avg = (degC_after[newIdx] + degC_after[nb]) / 2;
        const weight = 1.0 + 4.0 * avg;
        const opacity = 0.35 + 0.6 * avg;
        L.polyline([[withNew[newIdx][0],withNew[newIdx][1]],[withNew[nb][0],withNew[nb][1]]],
          {color:'#FFD700', weight, opacity}).addTo(layerLinks);
      }
    }
  }

  function makeSortable(){
    const thead=$('#resultTable thead'), tbody=$('#resultTable tbody');
    [...thead.querySelectorAll('th')].forEach((th,idx)=> th.addEventListener('click',()=>{
      const asc=!(th.classList.contains('sorted')&&th.classList.contains('asc'));
      [...thead.querySelectorAll('th')].forEach(h=>h.classList.remove('sorted','asc','desc'));
      th.classList.add('sorted',asc?'asc':'desc');
      const rows=[...tbody.rows];
      rows.sort((a,b)=>{
        const av=a.cells[idx].innerText.trim(), bv=b.cells[idx].innerText.trim();
        const an=parseFloat(av.replace(',','.')), bn=parseFloat(bv.replace(',','.'));
        const bothNum=!isNaN(an)&&!isNaN(bn); let s=bothNum? an-bn : av.localeCompare(bv,'sv');
        return asc? s : -s;
      });
      rows.forEach(r=>tbody.appendChild(r));
    }));
  }

  // Start
  loadCsvAuto();
  </script>
</body>
</html>